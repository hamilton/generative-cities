{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../../src/App.svelte",
    "../../src/primitives/Scene.svelte"
  ],
  "sourcesContent": [
    "<script>\nimport Bouncing from './scenes/Bouncing.svelte';\nimport Heights from './scenes/Heights.svelte';\nimport Hamlet from './scenes/Hamlet.svelte';\n\nlet which = 0;\nconst scenes = [\n  { name: 'Hamlet', component: Hamlet },\n  { name: 'Heights', component: Heights },\n  { name: 'Bouncing', component: Bouncing },\n\n];\n\n</script>\n\n<style>\n\nh1 {\n\tmargin: 0;\n\tmargin-bottom: var(--space-2x);\n\tfont-family: 'Seraphs Var';\n\tfont-variation-settings: 'wght' 100, 'SRFS' 6;\n\tline-height:1;\n}\n\nh1 sub {\n\tcolor: tomato;\n\tfont-size:.6em;\n\tfont-variation-settings: 'wght' 200, 'SRFS' 6;\n}\n</style>\n\n{#each scenes as {name, component}, i}\n\t{#if i === which}\n\t\t<svelte:component this={scenes[which].component} />\n\t{/if}\n{/each}\n\n\n<div class='scene-selection'>\n\t<h1>isometric map</h1>\n\t{#each scenes as {name, component}, i}\n\t<label>\n\t\t<input type=radio bind:group={which} value={i}>\n\t\t{name}\n\t</label>\n\t{/each}\n</div>",
    "<script>\nimport { setContext } from 'svelte';\nimport { fly } from 'svelte/transition';\nimport { cubicOut as easing } from 'svelte/easing';\n\nexport let width = 500;\nexport let tileSize = 25;\nexport let margin = 100;\nexport let grid = true;\n\nconst tileDimensions = width / tileSize / 2;\n\nconst H = width / 4 / tileDimensions;\nconst W = width / 2 / tileDimensions;\n\nconst coords = (cx, cy, h = 0) => ({\n  lx: cx * W + cy * W,\n  ly: margin + width / 4 + cx * (H) - cy * (H) - h,\n  tx: cx * W + cy * W + W,\n  ty: margin + width / 4 + cx * (H) - cy * (H) - H - h,\n  rx: cx * W + cy * W + W * 2,\n  ry: margin + width / 4 + cx * (H) - cy * (H) - h,\n  bx: cx * W + cy * W + W,\n  by: margin + width / 4 + cx * (H) - cy * (H) - H + H * 2 - h,\n});\n\nconst scale = (cx, cy, h = 0) => {\n  const obj = coords(cx, cy, h);\n  return [obj.lx, obj.ly];\n};\n\n// map* makes the transformation from x/y/z -> iso space\nconst mapX = (x, y, z = 0) => (x + y) * W;\nconst mapY = (x, y, z = 0) => (x - y - z * 2) * H;\nconst mapXY = (x, y, z = 0) => [mapX(x, y, z), mapY(x, y, z)];\n// place* helps place the object into the scene\n\nconst placeX = (x, y, z = 0) => mapX(x, y, z);\nconst placeY = (x, y, z = 0) => margin + width / 4 + mapY(x, y, z);\nconst placeXY = (x, y, z = 0) => [placeX(x, y, z), placeY(x, y, z)];\n\nconst rotate = (x, y, rad, centroid = [0, 0]) => {\n  const k = 2;\n  const x1 = (x - centroid[0]) * Math.cos(rad) - (y - centroid[1]) * Math.sin(rad) * k;\n  const y1 = ((x - centroid[0]) / k) * Math.sin(rad) + (y - centroid[1]) * Math.cos(rad);\n  return [x1 + centroid[0], y1 + centroid[1]];\n};\n\n\nconst mapToScene = (x, y, z = 0, angle = 0, centroid = [0.5, 0.5]) => {\n  const x1 = mapX(x, y);\n  const y1 = mapY(x, y);\n  const c = mapXY(...centroid);\n  const [rx, ry] = rotate(x1, y1, angle, c);\n  return [rx, ry - z * 2 * H];\n};\n\nsetContext('tileSize', tileSize);\nsetContext('width', width);\nsetContext('height', width / 2);\nsetContext('tileDimensions', tileDimensions);\nsetContext('coords', coords);\nsetContext('scale', scale);\nsetContext('margin', margin);\nsetContext('rotate', rotate);\nsetContext('mapToScene', mapToScene);\nsetContext('mapX', mapX);\nsetContext('mapY', mapY);\nsetContext('placeX', placeX);\nsetContext('placeY', placeY);\nsetContext('placeXY', placeXY);\n\n\nconst left = placeXY(0, 0);\nconst top = placeXY(0, tileDimensions);\nconst right = placeXY(tileDimensions, tileDimensions);\nconst bottom = placeXY(tileDimensions, 0);\n\n</script>\n\n<style>\ndiv {\n    display: grid;\n    align-items: center;\n    justify-items: center;\n}\nsvg {\n\tposition: fixed;\n\ttop:0;\n}\n\n</style>\n\n<div>\n\t<svg\n\t\tin:fly={{ duration: 200, y: 10 }}\n\t\twidth={width} height={width / 2 + margin * 2}>\n\t\t<defs>\n\t\t\t<clipPath id=\"shadow-clip\">\n\t\t\t\t<polygon \n\t\t\t\t\tpoints={[left, bottom, right, top].map((v) => v.join(',')).join(' ')} \n\t\t\t\t/>\n\t\t\t</clipPath>\n\t\t</defs>\n\t\t<slot name='defs'>\n\t\t\t<defs>\n\t\t\t\t<radialGradient id=\"treetop\" cx=\"20%\" cy=\"20%\" r=\"50%\" fx=\"20%\" fy=\"20%\">\n\t\t\t\t\t\t<stop offset=\"10%\" stop-color=\"#3a1e48\" />\n\t\t\t\t\t\t<stop offset=\"95%\" stop-color=\"#2e183a\" />\n\t\t\t\t</radialGradient>\n\t\t\t</defs>\n\t\t</slot>\n\n\t\t<slot name='earth'></slot>\n\t\t{#if grid}\n\t\t\t<g in:fly={{ duration: 200, y: -2, easing }}>\n\t\t\t\t{#each Array.from({ length: tileDimensions + 1 }).fill(null) as _,i }\n\t\t\t\t\t<line \n\t\t\t\t\t\tx1={coords(i, 0).lx}\n\t\t\t\t\t\tx2={coords(i, tileDimensions).lx}\n\t\t\t\t\t\ty1={coords(i, 0).ly}\n\t\t\t\t\t\ty2={coords(i, tileDimensions).ry}\n\t\t\t\t\t\tstroke=gray\n\t\t\t\t\t/>\n\t\t\t\t\t<line \n\t\t\t\t\t\tx1={coords(0, i).lx}\n\t\t\t\t\t\tx2={coords(tileDimensions, i).lx}\n\t\t\t\t\t\ty1={coords(0, i).ly}\n\t\t\t\t\t\ty2={coords(tileDimensions, i).ry}\n\t\t\t\t\t\tstroke=gray\n\t\t\t\t\t/>\n\t\t\t\t{/each}\n\t\t\t</g>\n\t\t{/if}\n\t\t<slot \n\t\t\tmapX={mapX} \n\t\t\tmapY={mapY} \n\t\t\tmapToScene={mapToScene}\n\t\t\tplaceX={placeX}\n\t\t\tplaceY={placeY}\n\t\t\t></slot>\n\t</svg>\n</div>"
  ],
  "names": [],
  "mappings": "AAiBA,EAAE,eAAC,CAAC,AACH,MAAM,CAAE,CAAC,CACT,aAAa,CAAE,IAAI,UAAU,CAAC,CAC9B,WAAW,CAAE,aAAa,CAC1B,uBAAuB,CAAE,MAAM,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC,CAAC,CAC7C,YAAY,CAAC,AACd,CAAC;AC0DD,GAAG,cAAC,CAAC,AACD,OAAO,CAAE,IAAI,CACb,WAAW,CAAE,MAAM,CACnB,aAAa,CAAE,MAAM,AACzB,CAAC,AACD,GAAG,cAAC,CAAC,AACJ,QAAQ,CAAE,KAAK,CACf,IAAI,CAAC,AACN,CAAC"
}